{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "985eeccb",
   "metadata": {},
   "source": [
    "# Natural gradients\n",
    "\n",
    "This notebook shows some basic usage of the natural gradient optimizer, both on its own and in combination with Adam optimizer."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "5274081e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:47.135566Z",
     "iopub.status.busy": "2022-09-20T14:23:47.135253Z",
     "iopub.status.idle": "2022-09-20T14:23:51.294505Z",
     "shell.execute_reply": "2022-09-20T14:23:51.293889Z"
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-09-20 14:23:47.350530: I tensorflow/core/platform/cpu_feature_guard.cc:193] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 AVX512F FMA\n",
      "To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n",
      "2022-09-20 14:23:47.490318: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcudart.so.11.0'; dlerror: libcudart.so.11.0: cannot open shared object file: No such file or directory\n",
      "2022-09-20 14:23:47.490350: I tensorflow/stream_executor/cuda/cudart_stub.cc:29] Ignore above cudart dlerror if you do not have a GPU set up on your machine.\n",
      "2022-09-20 14:23:47.521221: E tensorflow/stream_executor/cuda/cuda_blas.cc:2981] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-09-20 14:23:48.157505: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libnvinfer.so.7'; dlerror: libnvinfer.so.7: cannot open shared object file: No such file or directory\n",
      "2022-09-20 14:23:48.157582: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libnvinfer_plugin.so.7'; dlerror: libnvinfer_plugin.so.7: cannot open shared object file: No such file or directory\n",
      "2022-09-20 14:23:48.157590: W tensorflow/compiler/tf2tensorrt/utils/py_utils.cc:38] TF-TRT Warning: Cannot dlopen some TensorRT libraries. If you would like to use Nvidia GPU with TensorRT, please make sure the missing libraries mentioned above are installed properly.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/circleci/project/gpflow/experimental/utils.py:42: UserWarning: You're calling gpflow.experimental.check_shapes.decorator.check_shapes which is considered *experimental*. Expect: breaking changes, poor documentation, and bugs.\n",
      "  warn(\n",
      "/home/circleci/project/gpflow/experimental/utils.py:42: UserWarning: You're calling gpflow.experimental.check_shapes.inheritance.inherit_check_shapes which is considered *experimental*. Expect: breaking changes, poor documentation, and bugs.\n",
      "  warn(\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-09-20 14:23:51.271172: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcuda.so.1'; dlerror: libcuda.so.1: cannot open shared object file: No such file or directory\n",
      "2022-09-20 14:23:51.271201: W tensorflow/stream_executor/cuda/cuda_driver.cc:263] failed call to cuInit: UNKNOWN ERROR (303)\n",
      "2022-09-20 14:23:51.271220: I tensorflow/stream_executor/cuda/cuda_diagnostics.cc:156] kernel driver does not appear to be running on this host (38e97909228e): /proc/driver/nvidia/version does not exist\n",
      "2022-09-20 14:23:51.271459: I tensorflow/core/platform/cpu_feature_guard.cc:193] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 AVX512F FMA\n",
      "To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n"
     ]
    }
   ],
   "source": [
    "import warnings\n",
    "import numpy as np\n",
    "import gpflow\n",
    "import tensorflow as tf\n",
    "\n",
    "from gpflow.ci_utils import reduce_in_tests\n",
    "from gpflow.models import VGP, GPR, SGPR, SVGP\n",
    "from gpflow.optimizers import NaturalGradient\n",
    "from gpflow.optimizers.natgrad import XiSqrtMeanVar\n",
    "from gpflow import set_trainable\n",
    "\n",
    "%matplotlib inline\n",
    "%precision 4\n",
    "\n",
    "np.random.seed(0)\n",
    "tf.random.set_seed(0)\n",
    "\n",
    "N, D = 100, 2\n",
    "batch_size = 50\n",
    "\n",
    "# inducing points\n",
    "M = 10\n",
    "\n",
    "x = np.random.uniform(size=(N, D))\n",
    "y = np.sin(10 * x[:, :1]) + 5 * x[:, 1:] ** 2\n",
    "\n",
    "data = (x, y)\n",
    "inducing_variable = tf.random.uniform((M, D))\n",
    "adam_learning_rate = 0.01\n",
    "iterations = reduce_in_tests(5)\n",
    "autotune = tf.data.experimental.AUTOTUNE"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0711f742",
   "metadata": {},
   "source": [
    "## VGP is a GPR"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3b75a3f",
   "metadata": {},
   "source": [
    "The following section demonstrates how natural gradients can turn VGP into GPR *in a single step, if the likelihood is Gaussian*."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fca6e1bf",
   "metadata": {},
   "source": [
    "Let's start by first creating a standard GPR model with Gaussian likelihood:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "32abb8bd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.297576Z",
     "iopub.status.busy": "2022-09-20T14:23:51.297124Z",
     "iopub.status.idle": "2022-09-20T14:23:51.350083Z",
     "shell.execute_reply": "2022-09-20T14:23:51.349415Z"
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/circleci/project/gpflow/experimental/utils.py:42: UserWarning: You're calling gpflow.experimental.check_shapes.checker.ShapeChecker.__init__ which is considered *experimental*. Expect: breaking changes, poor documentation, and bugs.\n",
      "  warn(\n"
     ]
    }
   ],
   "source": [
    "gpr = GPR(data, kernel=gpflow.kernels.Matern52())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b60508ca",
   "metadata": {},
   "source": [
    "The log marginal likelihood of the exact GP model is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "5e023815",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.352919Z",
     "iopub.status.busy": "2022-09-20T14:23:51.352602Z",
     "iopub.status.idle": "2022-09-20T14:23:51.398199Z",
     "shell.execute_reply": "2022-09-20T14:23:51.397623Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-139.5640"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "gpr.log_marginal_likelihood().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "757cac56",
   "metadata": {},
   "source": [
    "Now we will create an approximate model which approximates the true posterior via a variational Gaussian distribution.<br>We initialize the distribution to be zero mean and unit variance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "abc95659",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.400981Z",
     "iopub.status.busy": "2022-09-20T14:23:51.400672Z",
     "iopub.status.idle": "2022-09-20T14:23:51.453236Z",
     "shell.execute_reply": "2022-09-20T14:23:51.452580Z"
    }
   },
   "outputs": [],
   "source": [
    "vgp = VGP(data, kernel=gpflow.kernels.Matern52(), likelihood=gpflow.likelihoods.Gaussian())\n",
    "# (Note that GPflow's NaturalGradient optimizer does not implement diagonal covariance parametrization, i.e., it does not work for `q_diag=True`.)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "26d13f94",
   "metadata": {},
   "source": [
    "The log marginal likelihood lower bound (evidence lower bound or ELBO) of the approximate GP model is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "91c5376e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.456335Z",
     "iopub.status.busy": "2022-09-20T14:23:51.456037Z",
     "iopub.status.idle": "2022-09-20T14:23:51.494355Z",
     "shell.execute_reply": "2022-09-20T14:23:51.493769Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-426.9017"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "vgp.elbo().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9298108b",
   "metadata": {},
   "source": [
    "Obviously, our initial guess for the variational distribution is not correct, which results in a lower bound to the likelihood of the exact GPR model. We can optimize the variational parameters in order to get a tighter bound."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f3dd1c8",
   "metadata": {},
   "source": [
    "In fact, we only need to take **one step** in the natural gradient direction to recover the exact posterior:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "00afacab",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.519480Z",
     "iopub.status.busy": "2022-09-20T14:23:51.519131Z",
     "iopub.status.idle": "2022-09-20T14:23:51.616101Z",
     "shell.execute_reply": "2022-09-20T14:23:51.615372Z"
    }
   },
   "outputs": [],
   "source": [
    "natgrad_opt = NaturalGradient(gamma=1.0)\n",
    "variational_params = [(vgp.q_mu, vgp.q_sqrt)]\n",
    "natgrad_opt.minimize(vgp.training_loss, var_list=variational_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "370f6068",
   "metadata": {},
   "source": [
    "The ELBO of the approximate GP model after a single NatGrad step:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "96d5bfc7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.619379Z",
     "iopub.status.busy": "2022-09-20T14:23:51.619063Z",
     "iopub.status.idle": "2022-09-20T14:23:51.644383Z",
     "shell.execute_reply": "2022-09-20T14:23:51.643769Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-139.5641"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "vgp.elbo().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd5c52b8",
   "metadata": {},
   "source": [
    "## Optimize both variational parameters and kernel hyperparameters together\n",
    "\n",
    "In the Gaussian likelihood case we can iterate between an Adam update for the hyperparameters and a NatGrad update for the variational parameters. That way, we achieve optimization of hyperparameters as if the model were a GPR."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "551705ee",
   "metadata": {},
   "source": [
    "The trick is to forbid Adam from updating the variational parameters by setting them to not trainable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "7dc355e4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.648498Z",
     "iopub.status.busy": "2022-09-20T14:23:51.648162Z",
     "iopub.status.idle": "2022-09-20T14:23:51.671340Z",
     "shell.execute_reply": "2022-09-20T14:23:51.670670Z"
    }
   },
   "outputs": [],
   "source": [
    "# Stop Adam from optimizing the variational parameters\n",
    "set_trainable(vgp.q_mu, False)\n",
    "set_trainable(vgp.q_sqrt, False)\n",
    "\n",
    "adam_opt_for_vgp = tf.optimizers.Adam(adam_learning_rate)\n",
    "adam_opt_for_gpr = tf.optimizers.Adam(adam_learning_rate)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "dedae008",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.674624Z",
     "iopub.status.busy": "2022-09-20T14:23:51.674112Z",
     "iopub.status.idle": "2022-09-20T14:23:51.925099Z",
     "shell.execute_reply": "2022-09-20T14:23:51.924197Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPR with Adam: iteration 1 likelihood -139.2548\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPR with Adam: iteration 2 likelihood -138.9456\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPR with Adam: iteration 3 likelihood -138.6363\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPR with Adam: iteration 4 likelihood -138.3270\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPR with Adam: iteration 5 likelihood -138.0177\n"
     ]
    }
   ],
   "source": [
    "for i in range(iterations):\n",
    "    adam_opt_for_gpr.minimize(gpr.training_loss, var_list=gpr.trainable_variables)\n",
    "    likelihood = gpr.log_marginal_likelihood()\n",
    "    tf.print(f\"GPR with Adam: iteration {i + 1} likelihood {likelihood:.04f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "072f502d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:51.928208Z",
     "iopub.status.busy": "2022-09-20T14:23:51.927912Z",
     "iopub.status.idle": "2022-09-20T14:23:52.606870Z",
     "shell.execute_reply": "2022-09-20T14:23:52.606193Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "VGP with NaturalGradient and Adam: iteration 1 likelihood -139.2581\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "VGP with NaturalGradient and Adam: iteration 2 likelihood -138.9489\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "VGP with NaturalGradient and Adam: iteration 3 likelihood -138.6397\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "VGP with NaturalGradient and Adam: iteration 4 likelihood -138.3305\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "VGP with NaturalGradient and Adam: iteration 5 likelihood -138.0213\n"
     ]
    }
   ],
   "source": [
    "for i in range(iterations):\n",
    "    natgrad_opt.minimize(vgp.training_loss, var_list=variational_params)\n",
    "    adam_opt_for_vgp.minimize(vgp.training_loss, var_list=vgp.trainable_variables)\n",
    "    likelihood = vgp.elbo()\n",
    "    tf.print(f\"VGP with NaturalGradient and Adam: iteration {i + 1} likelihood {likelihood:.04f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c694b298",
   "metadata": {},
   "source": [
    "Compare GPR and VGP lengthscales after optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "dd6517ca",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:52.609815Z",
     "iopub.status.busy": "2022-09-20T14:23:52.609511Z",
     "iopub.status.idle": "2022-09-20T14:23:52.615134Z",
     "shell.execute_reply": "2022-09-20T14:23:52.614471Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPR lengthscales = 0.9687\n",
      "VGP lengthscales = 0.9687\n"
     ]
    }
   ],
   "source": [
    "print(f\"GPR lengthscales = {gpr.kernel.lengthscales.numpy():.04f}\")\n",
    "print(f\"VGP lengthscales = {vgp.kernel.lengthscales.numpy():.04f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ff4b5737",
   "metadata": {},
   "source": [
    "## Natural gradients also work for the sparse model\n",
    "Similarly, natural gradients turn SVGP into SGPR in the Gaussian likelihood case. <br>\n",
    "We can again combine natural gradients with Adam to update both variational parameters and hyperparameters too.<br>\n",
    "Here we'll just do a single natural step demonstration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "0a33a11e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:52.618046Z",
     "iopub.status.busy": "2022-09-20T14:23:52.617763Z",
     "iopub.status.idle": "2022-09-20T14:23:52.684641Z",
     "shell.execute_reply": "2022-09-20T14:23:52.683953Z"
    }
   },
   "outputs": [],
   "source": [
    "svgp = SVGP(\n",
    "    kernel=gpflow.kernels.Matern52(),\n",
    "    likelihood=gpflow.likelihoods.Gaussian(),\n",
    "    inducing_variable=inducing_variable,\n",
    ")\n",
    "sgpr = SGPR(data, kernel=gpflow.kernels.Matern52(), inducing_variable=inducing_variable)\n",
    "\n",
    "for model in svgp, sgpr:\n",
    "    model.likelihood.variance.assign(0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7dcdcf3a",
   "metadata": {},
   "source": [
    "Analytically optimal sparse model ELBO:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "8813d1be",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:52.688050Z",
     "iopub.status.busy": "2022-09-20T14:23:52.687756Z",
     "iopub.status.idle": "2022-09-20T14:23:52.721386Z",
     "shell.execute_reply": "2022-09-20T14:23:52.720728Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-227.9840"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sgpr.elbo().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d5a8cdd4",
   "metadata": {},
   "source": [
    "SVGP ELBO before natural gradient step:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "16ddd28a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:52.724043Z",
     "iopub.status.busy": "2022-09-20T14:23:52.723766Z",
     "iopub.status.idle": "2022-09-20T14:23:52.773939Z",
     "shell.execute_reply": "2022-09-20T14:23:52.773332Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-3326.8429"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "svgp.elbo(data).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "15947cce",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:52.777040Z",
     "iopub.status.busy": "2022-09-20T14:23:52.776762Z",
     "iopub.status.idle": "2022-09-20T14:23:56.902307Z",
     "shell.execute_reply": "2022-09-20T14:23:56.901632Z"
    }
   },
   "outputs": [],
   "source": [
    "variational_params = [(svgp.q_mu, svgp.q_sqrt)]\n",
    "\n",
    "natgrad_opt = NaturalGradient(gamma=1.0)\n",
    "natgrad_opt.minimize(svgp.training_loss_closure(data), var_list=variational_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a60e49ae",
   "metadata": {},
   "source": [
    "SVGP ELBO after a single natural gradient step:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "ae49c8b8",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:56.906615Z",
     "iopub.status.busy": "2022-09-20T14:23:56.906276Z",
     "iopub.status.idle": "2022-09-20T14:23:56.946069Z",
     "shell.execute_reply": "2022-09-20T14:23:56.945491Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-227.9840"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "svgp.elbo(data).numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7b0f24a",
   "metadata": {},
   "source": [
    "## Minibatches\n",
    "A crucial property of the natural gradient method is that it still works with minibatches.\n",
    "In practice though, we need to use a smaller gamma."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "ae03ddbd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:23:56.948790Z",
     "iopub.status.busy": "2022-09-20T14:23:56.948495Z",
     "iopub.status.idle": "2022-09-20T14:24:01.257103Z",
     "shell.execute_reply": "2022-09-20T14:24:01.256475Z"
    }
   },
   "outputs": [],
   "source": [
    "natgrad_opt = NaturalGradient(gamma=0.1)\n",
    "\n",
    "data_minibatch = (\n",
    "    tf.data.Dataset.from_tensor_slices(data)\n",
    "    .prefetch(autotune)\n",
    "    .repeat()\n",
    "    .shuffle(N)\n",
    "    .batch(batch_size)\n",
    ")\n",
    "data_minibatch_it = iter(data_minibatch)\n",
    "\n",
    "\n",
    "svgp_objective = svgp.training_loss_closure(data_minibatch_it)\n",
    "for _ in range(reduce_in_tests(100)):\n",
    "    natgrad_opt.minimize(svgp_objective, var_list=variational_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01fd9191",
   "metadata": {},
   "source": [
    "Minibatch SVGP ELBO after NatGrad optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "9332fef9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:01.260073Z",
     "iopub.status.busy": "2022-09-20T14:24:01.259803Z",
     "iopub.status.idle": "2022-09-20T14:24:04.643597Z",
     "shell.execute_reply": "2022-09-20T14:24:04.643024Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-136.1650"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.average([svgp.elbo(next(data_minibatch_it)) for _ in range(reduce_in_tests(100))])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cca71468",
   "metadata": {},
   "source": [
    "## Comparison with ordinary gradients in the conjugate case\n",
    "\n",
    "(Take home message: natural gradients are always better)\n",
    "\n",
    "Compared to SVGP with ordinary gradients with minibatches, the natural gradient optimizer is much faster in the Gaussian case.\n",
    "\n",
    "Here we'll do hyperparameter learning together with optimization of the variational parameters, comparing the interleaved natural gradient approach and the one using ordinary gradients for the hyperparameters and variational parameters jointly.\n",
    "\n",
    "**NOTE:** Again we need to compromise for smaller gamma value, which we'll keep *fixed* during the optimization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "03d6cd52",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:04.646420Z",
     "iopub.status.busy": "2022-09-20T14:24:04.646120Z",
     "iopub.status.idle": "2022-09-20T14:24:04.703832Z",
     "shell.execute_reply": "2022-09-20T14:24:04.703207Z"
    }
   },
   "outputs": [],
   "source": [
    "svgp_ordinary = SVGP(\n",
    "    kernel=gpflow.kernels.Matern52(),\n",
    "    likelihood=gpflow.likelihoods.Gaussian(),\n",
    "    inducing_variable=inducing_variable,\n",
    ")\n",
    "svgp_natgrad = SVGP(\n",
    "    kernel=gpflow.kernels.Matern52(),\n",
    "    likelihood=gpflow.likelihoods.Gaussian(),\n",
    "    inducing_variable=inducing_variable,\n",
    ")\n",
    "\n",
    "# ordinary gradients with Adam for SVGP\n",
    "ordinary_adam_opt = tf.optimizers.Adam(adam_learning_rate)\n",
    "\n",
    "# NatGrads and Adam for SVGP\n",
    "# Stop Adam from optimizing the variational parameters\n",
    "set_trainable(svgp_natgrad.q_mu, False)\n",
    "set_trainable(svgp_natgrad.q_sqrt, False)\n",
    "\n",
    "# Create the optimize_tensors for SVGP\n",
    "natgrad_adam_opt = tf.optimizers.Adam(adam_learning_rate)\n",
    "\n",
    "natgrad_opt = NaturalGradient(gamma=0.1)\n",
    "variational_params = [(svgp_natgrad.q_mu, svgp_natgrad.q_sqrt)]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f311a9d8",
   "metadata": {},
   "source": [
    "Let's optimize the models:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "60e98c14",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:04.707215Z",
     "iopub.status.busy": "2022-09-20T14:24:04.706924Z",
     "iopub.status.idle": "2022-09-20T14:24:11.913335Z",
     "shell.execute_reply": "2022-09-20T14:24:11.912657Z"
    }
   },
   "outputs": [],
   "source": [
    "data_minibatch = (\n",
    "    tf.data.Dataset.from_tensor_slices(data)\n",
    "    .prefetch(autotune)\n",
    "    .repeat()\n",
    "    .shuffle(N)\n",
    "    .batch(batch_size)\n",
    ")\n",
    "data_minibatch_it = iter(data_minibatch)\n",
    "\n",
    "\n",
    "svgp_ordinary_loss = svgp_ordinary.training_loss_closure(data_minibatch_it)\n",
    "svgp_natgrad_loss = svgp_natgrad.training_loss_closure(data_minibatch_it)\n",
    "\n",
    "\n",
    "for _ in range(reduce_in_tests(100)):\n",
    "    ordinary_adam_opt.minimize(svgp_ordinary_loss, var_list=svgp_ordinary.trainable_variables)\n",
    "\n",
    "\n",
    "for _ in range(reduce_in_tests(100)):\n",
    "    natgrad_adam_opt.minimize(svgp_natgrad_loss, var_list=svgp_natgrad.trainable_variables)\n",
    "    natgrad_opt.minimize(svgp_natgrad_loss, var_list=variational_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c84b2d9f",
   "metadata": {},
   "source": [
    "SVGP ELBO after ordinary `Adam` optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "b667c14a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:11.916688Z",
     "iopub.status.busy": "2022-09-20T14:24:11.916231Z",
     "iopub.status.idle": "2022-09-20T14:24:15.808522Z",
     "shell.execute_reply": "2022-09-20T14:24:15.807949Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-82.7712"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.average([svgp_ordinary.elbo(next(data_minibatch_it)) for _ in range(reduce_in_tests(100))])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "098acbc7",
   "metadata": {},
   "source": [
    "SVGP ELBO after `NaturalGradient` and `Adam` optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "d6d3fcbe",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:15.811562Z",
     "iopub.status.busy": "2022-09-20T14:24:15.811243Z",
     "iopub.status.idle": "2022-09-20T14:24:19.470575Z",
     "shell.execute_reply": "2022-09-20T14:24:19.469974Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-73.0862"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.average([svgp_natgrad.elbo(next(data_minibatch_it)) for _ in range(reduce_in_tests(100))])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1fe1b8ff",
   "metadata": {},
   "source": [
    "## Comparison with ordinary gradients in the non-conjugate case\n",
    "\n",
    "### Binary classification\n",
    "\n",
    "(Take home message: natural gradients are usually better)\n",
    "\n",
    "We can use natural gradients even when the likelihood isn't Gaussian. It isn't guaranteed to be better, but it usually is better in practical situations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "12dedc04",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:19.473972Z",
     "iopub.status.busy": "2022-09-20T14:24:19.473647Z",
     "iopub.status.idle": "2022-09-20T14:24:19.530438Z",
     "shell.execute_reply": "2022-09-20T14:24:19.529716Z"
    }
   },
   "outputs": [],
   "source": [
    "y_binary = np.random.choice([1.0, -1], size=x.shape)\n",
    "vgp_data = (x, y_binary)\n",
    "\n",
    "vgp_bernoulli = VGP(\n",
    "    vgp_data, kernel=gpflow.kernels.Matern52(), likelihood=gpflow.likelihoods.Bernoulli()\n",
    ")\n",
    "vgp_bernoulli_natgrad = VGP(\n",
    "    vgp_data, kernel=gpflow.kernels.Matern52(), likelihood=gpflow.likelihoods.Bernoulli()\n",
    ")\n",
    "\n",
    "# ordinary gradients with Adam for VGP with Bernoulli likelihood\n",
    "adam_opt = tf.optimizers.Adam(adam_learning_rate)\n",
    "\n",
    "# NatGrads and Adam for VGP with Bernoulli likelihood\n",
    "# Stop Adam from optimizing the variational parameters\n",
    "set_trainable(vgp_bernoulli_natgrad.q_mu, False)\n",
    "set_trainable(vgp_bernoulli_natgrad.q_sqrt, False)\n",
    "\n",
    "# Create the optimize_tensors for VGP with natural gradients\n",
    "natgrad_adam_opt = tf.optimizers.Adam(adam_learning_rate)\n",
    "natgrad_opt = NaturalGradient(gamma=0.1)\n",
    "variational_params = [(vgp_bernoulli_natgrad.q_mu, vgp_bernoulli_natgrad.q_sqrt)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "0d93d401",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:19.534280Z",
     "iopub.status.busy": "2022-09-20T14:24:19.533954Z",
     "iopub.status.idle": "2022-09-20T14:24:34.215051Z",
     "shell.execute_reply": "2022-09-20T14:24:34.214423Z"
    }
   },
   "outputs": [],
   "source": [
    "# Optimize vgp_bernoulli\n",
    "for _ in range(reduce_in_tests(100)):\n",
    "    adam_opt.minimize(vgp_bernoulli.training_loss, var_list=vgp_bernoulli.trainable_variables)\n",
    "\n",
    "# Optimize vgp_bernoulli_natgrad\n",
    "for _ in range(reduce_in_tests(100)):\n",
    "    adam_opt.minimize(\n",
    "        vgp_bernoulli_natgrad.training_loss, var_list=vgp_bernoulli_natgrad.trainable_variables\n",
    "    )\n",
    "    natgrad_opt.minimize(vgp_bernoulli_natgrad.training_loss, var_list=variational_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c857b13c",
   "metadata": {},
   "source": [
    "VGP ELBO after ordinary `Adam` optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "ed785d42",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:34.218228Z",
     "iopub.status.busy": "2022-09-20T14:24:34.217956Z",
     "iopub.status.idle": "2022-09-20T14:24:34.239695Z",
     "shell.execute_reply": "2022-09-20T14:24:34.239214Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-144.2140"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "vgp_bernoulli.elbo().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b8161409",
   "metadata": {},
   "source": [
    "VGP ELBO after `NaturalGradient` + `Adam` optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "6905a71d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:34.242065Z",
     "iopub.status.busy": "2022-09-20T14:24:34.241818Z",
     "iopub.status.idle": "2022-09-20T14:24:34.262990Z",
     "shell.execute_reply": "2022-09-20T14:24:34.262513Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-142.8380"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "vgp_bernoulli_natgrad.elbo().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a6da783c",
   "metadata": {},
   "source": [
    "We can also choose to run natural gradients in another parameterization.<br>\n",
    "The sensible choice is the model parameters (q_mu, q_sqrt), which is already in GPflow."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "7f135686",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:34.265269Z",
     "iopub.status.busy": "2022-09-20T14:24:34.265026Z",
     "iopub.status.idle": "2022-09-20T14:24:34.289983Z",
     "shell.execute_reply": "2022-09-20T14:24:34.289475Z"
    }
   },
   "outputs": [],
   "source": [
    "vgp_bernoulli_natgrads_xi = VGP(\n",
    "    vgp_data, kernel=gpflow.kernels.Matern52(), likelihood=gpflow.likelihoods.Bernoulli()\n",
    ")\n",
    "\n",
    "# Stop Adam from optimizing the variational parameters\n",
    "set_trainable(vgp_bernoulli_natgrads_xi.q_mu, False)\n",
    "set_trainable(vgp_bernoulli_natgrads_xi.q_sqrt, False)\n",
    "\n",
    "# Create the optimize_tensors for VGP with Bernoulli likelihood\n",
    "adam_opt = tf.optimizers.Adam(adam_learning_rate)\n",
    "natgrad_opt = NaturalGradient(gamma=0.01)\n",
    "\n",
    "variational_params = [\n",
    "    (vgp_bernoulli_natgrads_xi.q_mu, vgp_bernoulli_natgrads_xi.q_sqrt, XiSqrtMeanVar())\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "4b5f7770",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:34.292419Z",
     "iopub.status.busy": "2022-09-20T14:24:34.292176Z",
     "iopub.status.idle": "2022-09-20T14:24:46.530101Z",
     "shell.execute_reply": "2022-09-20T14:24:46.529474Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WARNING:tensorflow:Calling GradientTape.gradient on a persistent tape inside its context is significantly less efficient than calling it outside the context (it causes the gradient ops to be recorded on the tape, leading to increased CPU and memory usage). Only call GradientTape.gradient inside the context if you actually want to trace the gradient in order to compute higher order derivatives.\n"
     ]
    }
   ],
   "source": [
    "# Optimize vgp_bernoulli_natgrads_xi\n",
    "for _ in range(reduce_in_tests(100)):\n",
    "    adam_opt.minimize(\n",
    "        vgp_bernoulli_natgrads_xi.training_loss,\n",
    "        var_list=vgp_bernoulli_natgrads_xi.trainable_variables,\n",
    "    )\n",
    "\n",
    "    natgrad_opt.minimize(vgp_bernoulli_natgrads_xi.training_loss, var_list=variational_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "442b53ef",
   "metadata": {},
   "source": [
    "VGP ELBO after `NaturalGradient` with `XiSqrtMeanVar` + `Adam` optimization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "410a51cc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-09-20T14:24:46.533145Z",
     "iopub.status.busy": "2022-09-20T14:24:46.532868Z",
     "iopub.status.idle": "2022-09-20T14:24:46.555436Z",
     "shell.execute_reply": "2022-09-20T14:24:46.554900Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-143.0989"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "vgp_bernoulli_natgrads_xi.elbo().numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8606842d",
   "metadata": {},
   "source": [
    "With sufficiently small steps, it shouldn't make a difference which transform is used, but for large\n",
    "steps this can make a difference in practice."
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,.pct.py:percent"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
