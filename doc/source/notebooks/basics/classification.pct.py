# ---
# jupyter:
#   jupytext:
#     formats: ipynb,.pct.py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.3.3
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# %% [markdown]
# # Basic (binary) GP classification model
#
#
# This notebook shows how to build a GP classification model using variational inference. Here we consider binary (two-class, 0 vs. 1) classification only (there is a separate notebook on [multiclass classification](../advanced/multiclass_classification.ipynb)). We first look at a one-dimensional example, and then show how you can adapt this when the input space is two-dimensional.

# %%
import numpy as np
import gpflow
import tensorflow as tf

import matplotlib.pyplot as plt
import matplotlib
# %matplotlib inline

matplotlib.rcParams['figure.figsize'] = (8, 4)

# %% [markdown]
# ## One-dimensional example
#
# First of all, let's have a look at the data. `X` and `Y` denote the input and output values. **NOTE:** `X` and `Y` must be two-dimensional NumPy arrays, $N \times 1$ or $N \times D$, where $D$ is the number of input dimensions/features, with the same number of rows as $N$ (one for each data point):

# %%
X = np.genfromtxt('data/classif_1D_X.csv').reshape(-1, 1)
Y = np.genfromtxt('data/classif_1D_Y.csv').reshape(-1, 1)

plt.figure(figsize=(10, 6))
plt.plot(X, Y, 'C3x', ms=8, mew=2);

# %% [markdown]
# ### Reminders on GP classification
#
# For a binary classification model using GPs, we can simply use a `Bernoulli` likelihood. The details of the generative model are as follows:
#
# __1. Define the latent GP:__ we start from a Gaussian process $f \sim \mathcal{GP}(0, k(., .))$:

# %%
# build the kernel and covariance matrix
k = gpflow.kernels.Matern52(variance=20.)
x_grid = np.linspace(0, 6, 200).reshape(-1, 1)
K = k(x_grid)

# sample from a multivariate normal
L = np.linalg.cholesky(K)
f_grid = np.dot(L, np.random.RandomState(6).randn(200, 5))
plt.plot(x_grid, f_grid, 'C0', linewidth=1)
plt.plot(x_grid, f_grid[:, 1], 'C0', linewidth=2);


# %% [markdown]
# __2. Squash them to $[0, 1]$:__ the samples of the GP are mapped to $[0, 1]$ using the logistic inverse link function: $g(x) = \frac{\exp(f(x))}{1 + \exp(f(x))}$.

# %%
def logistic(f):
    return np.exp(f) / (1 + np.exp(f))
p_grid = logistic(f_grid)
plt.plot(x_grid, p_grid, 'C1', linewidth=1)
plt.plot(x_grid, p_grid[:, 1], 'C1', linewidth=2);

# %% [markdown]
# __3. Sample from a Bernoulli:__ for each observation point $X_i$, the class label $Y_i \in \{0, 1\}$ is generated by sampling from a Bernoulli distribution $Y_i \sim \mathcal{B}(g(X_i))$.

# %%
# Select some input locations
ind = np.random.randint(0, 200, (30,))
X_gen = x_grid[ind]

# evaluate probability and get Bernoulli draws
p = p_grid[ind, 1:2]
Y_gen = np.random.binomial(1, p)

# plot
plt.plot(x_grid, p_grid[:, 1], 'C1', linewidth=2)
plt.plot(X_gen, p, 'C1o', ms=6)
plt.plot(X_gen, Y_gen, 'C3x', ms=8, mew=2);

# %% [markdown]
# ### Implementation with GPflow
#
# For the model described above, the posterior $f(x)|Y$ (say $p$) is not Gaussian any more and does not have a closed-form expression. A common approach is then to look for the best approximation of this posterior by a tractable distribution (say $q$) such as a Gaussian distribution. In variational inference, the quality of an approximation is measured by the Kullback-Leibler divergence $\mathrm{KL}[q \| p]$. For more details on this model, see Nickisch and Rasmussen (2008).
#
# The inference problem is thus turned into an optimization problem: finding the best parameters for $q$. In our case, we introduce $U \sim \mathcal{N}(q_\mu, q_\Sigma)$, and we choose $q$ to have the same distribution as $f | f(X) = U$. The parameters $q_\mu$ and $q_\Sigma$ can be seen as parameters of $q$, which can be optimized in order to minimise  $\mathrm{KL}[q \| p]$. 
#
# This variational inference model is called `VGP` in GPflow:

# %%
m = gpflow.models.VGP((X, Y),
                      likelihood=gpflow.likelihoods.Bernoulli(),
                      kernel=gpflow.kernels.Matern52())

o = gpflow.optimizers.Scipy()

@tf.function(autograph=False)
def objective():
    return - m.log_marginal_likelihood()
o.minimize(objective, variables=m.trainable_variables)

# %% [markdown]
# We can now inspect the result of the optimization with `gpflow.utilities.print_summary(m)`:

# %%
gpflow.utilities.print_summary(m, fmt='notebook')

# %% [markdown]
# In this table, the first two lines are associated with the kernel parameters, and the last two correspond to the variational parameters. **NOTE:** In practice, $q_\Sigma$ is actually parameterized by its lower-triangular square root $q_\Sigma = q_\text{sqrt} q_\text{sqrt}^T$ in order to ensure its positive-definiteness.
#
# For more details on how to handle models in GPflow (getting and setting parameters, fixing some of them during optimization, using priors, and so on), see [Manipulating GPflow models](../understanding/models.ipynb).

# %% [markdown]
# ### Predictions
#
# Finally, we will see how to use model predictions to plot the resulting model. We will replicate the figures of the generative model above, but using the approximate posterior distribution given by the model.

# %%
plt.figure(figsize=(12, 8))

# bubble fill the predictions
mu, var = m.predict_f(x_grid)

plt.fill_between(x_grid.flatten(),
                 np.ravel(mu + 2 * np.sqrt(var)),
                 np.ravel(mu - 2 * np.sqrt(var)),
                 alpha=0.3, color='C0')
    
# plot samples
samples = m.predict_f_samples(x_grid, 10).numpy().squeeze().T

plt.plot(x_grid, samples, 'C0', lw=1)
    
# plot p-samples
p = logistic(samples)  # exp(samples) / (1 + exp(samples))
plt.plot(x_grid, p, 'C1', lw=1)

# plot data
plt.plot(X, Y, 'C3x', ms=8, mew=2)
plt.ylim((-3,3))

# %% [markdown]
# ## Two-dimensional example
#
# In this section we will use the following data:

# %%
X = np.loadtxt('data/banana_X_train', delimiter=',')
Y = np.loadtxt('data/banana_Y_train', delimiter=',').reshape(-1,1)
mask = Y[:, 0]==1

plt.figure(figsize=(6, 6))
plt.plot(X[mask, 0], X[mask, 1], 'oC0', mew=0, alpha=0.5)
plt.plot(X[np.logical_not(mask), 0], X[np.logical_not(mask), 1], 'oC1', mew=0, alpha=0.5);

# %% [markdown]
# The model definition is the same as above; the only important difference is that we now specify that the kernel operates over a two-dimensional input space:

# %%
m = gpflow.models.VGP((X, Y),
                      kernel=gpflow.kernels.SquaredExponential(),
                      likelihood=gpflow.likelihoods.Bernoulli())

opt = gpflow.optimizers.Scipy()
@tf.function(autograph=False)
def objective():
    return - m.log_marginal_likelihood()
opt.minimize(objective,
             variables=m.trainable_variables,
             options=dict(maxiter=25), method='L-BFGS-B')  # TODO: make work with BFGS
# in practice, the optimization needs around 250 iterations to converge

# %% [markdown]
# We can now plot the predicted decision boundary between the two classes. To do so, we can equivalently plot the contour lines $E[f(x)|Y]=0$, or $E[g(f(x))|Y]=0.5$. We will do the latter, because it allows us to introduce the `predict_y` function, which returns the mean and variance at test points:

# %%
x_grid = np.linspace(-3, 3, 40)
xx, yy = np.meshgrid(x_grid, x_grid)
Xplot = np.vstack((xx.flatten(), yy.flatten())).T

p, _ = m.predict_y(Xplot)  # here we only care about the mean
plt.figure(figsize=(7, 7))
plt.plot(X[mask, 0], X[mask, 1], 'oC0', mew=0, alpha=0.5)
plt.plot(X[np.logical_not(mask), 0], X[np.logical_not(mask), 1], 'oC1', mew=0, alpha=0.5);

plt.contour(xx, yy, p.numpy().reshape(*xx.shape), [0.5],  # plot the p=0.5 contour line only
            colors='k', linewidths=1.8, zorder=100);

# %% [markdown]
# ## Further reading
#
# There are dedicated notebooks giving more details on how to manipulate [models](../understanding/models.ipynb) and [kernels](../advanced/kernels.ipynb).
#
# This notebook covers only very basic classification models. You might also be interested in:
#   * [Multiclass classification](../advanced/multiclass_classification.ipynb) if you have more than two classes.
#   * [Sparse models](../advanced/gps_for_big_data.ipynb). The models above have one inducing variable $U_i$ per observation point $X_i$, which does not scale to large datasets.   Sparse Variational GP (SVGP) is an efficient alternative where the variables $U_i$ are defined at some inducing input locations $Z_i$ that can also be optimized.
#   * [Exact inference](../advanced/mcmc.ipynb). We have seen that variational inference provides an approximation to the posterior. GPflow also supports exact inference using Markov Chain Monte Carlo (MCMC) methods, and the kernel parameters can also be assigned prior distributions in order to avoid point estimates.
#   
# ## References
#
# Hannes Nickisch and Carl Edward Rasmussen. 'Approximations for binary Gaussian process classification'. *Journal of Machine Learning Research* 9(Oct):2035--2078, 2008.
